# 一.java多线程入门

1. [Java 多线程（一）—–概念与原理](http://cmsblogs.com/?p=1246)
2. [Java 多线程（二）—–创建与启动](http://cmsblogs.com/?p=1257)
3. [Java 多线程（三）—–线程栈模型与线程的变量](http://cmsblogs.com/?p=1265)
4. [Java 多线程（四）—–线程状态的转换](http://cmsblogs.com/?p=1273)
5. [Java 多线程（五）—–线程的同步与锁](http://cmsblogs.com/?p=1278)
6. [Java 多线程（六）—–线程的交互](http://cmsblogs.com/?p=1280)
7. [Java 多线程（七）—–线程的调度](http://cmsblogs.com/?p=1282)
8. [Java 多线程（八）—–线程的同步](http://cmsblogs.com/?p=1298)
9. [Java 多线程（九）—–并发协作-生产者消费者模型](http://cmsblogs.com/?p=1300)
10. [Java 多线程（十）—–并发协作：死锁](http://cmsblogs.com/?p=1312)
11. [Java 多线程（十一）—–有返回值的线程](http://cmsblogs.com/?p=1314)
12. [Java 多线程（十二）—–锁](http://cmsblogs.com/?p=1316)
13. [Java 多线程（十三）—–信号量](http://cmsblogs.com/?p=1318)
14. [Java 多线程（十四）—–阻塞队列](http://cmsblogs.com/?p=1320)
15. [Java 多线程（十五）—–阻塞栈](http://cmsblogs.com/?p=1322)
16. [Java 多线程（十六）—–条件变量](http://cmsblogs.com/?p=1326)




# 二.深入理解java内存模型

1. [深入理解 Java 内存模型（一）——基础](http://cmsblogs.com/?p=3992)
2. [深入理解 Java 内存模型（二）——重排序](http://cmsblogs.com/?p=3994)
3. [深入理解 Java 内存模型（三）——顺序一致性](http://cmsblogs.com/?p=3996)
4. [深入理解 Java 内存模型（四）——volatile](http://cmsblogs.com/?p=3998)
5. [深入理解 Java 内存模型（五）——锁](http://cmsblogs.com/?p=4000)
6. [深入理解 Java 内存模型（六）——final](http://cmsblogs.com/?p=4002)
7. [深入理解 Java 内存模型（七）——总结](http://cmsblogs.com/?p=4004)
8. [JVM内存结构 VS Java内存模型 VS Java对象模型](http://cmsblogs.com/?p=4006)
9. [再有人问你Java内存模型是什么，就把这篇文章发给他](http://cmsblogs.com/?p=4008)
10. [内存模型是怎么解决缓存一致性问题的？](http://cmsblogs.com/?p=4010)
    1. 加lock
    2. 缓存一致性协议（硬件层面）

# 三.深入java并发

1.[【死磕Java并发】—–深入分析synchronized 的实现原理](http://cmsblogs.com/?p=2071)

2.[【死磕Java并发】—–深入分析volatile的实现原理](http://cmsblogs.com/?p=2092)

3.[【死磕Java并发】—–Java内存模型之happens-before](http://cmsblogs.com/?p=2102)

4.[【死磕Java并发】—–Java内存模型之重排序](http://cmsblogs.com/?p=2116)

5.[【死磕Java并发】—–Java内存模型之分析volatile](http://cmsblogs.com/?p=2148)

6.[【死磕Java并发】—–Java内存模型之从JMM角度分析DCL](http://cmsblogs.com/?p=2161)
7.[【死磕Java并发】—–J.U.C之AQS：AQS简介](http://cmsblogs.com/?p=2174)

8.[【死磕Java并发】—–J.U.C之AQS：CLH同步队列](http://cmsblogs.com/?p=2188)

9.[【死磕Java并发】—–J.U.C之AQS：同步状态的获取与释放](http://cmsblogs.com/?p=2197)

10.[【死磕Java并发】—–J.U.C之AQS：阻塞和唤醒线程](http://cmsblogs.com/?p=2205)

11.[【死磕Java并发】—–J.U.C之重入锁：ReentrantLock](http://cmsblogs.com/?p=2210)

12.[【死磕Java并发】—–J.U.C之读写锁：ReentrantReadWriteLock](http://cmsblogs.com/?p=2213)

13.[【死磕Java并发】—–J.U.C之Condition](http://cmsblogs.com/?p=2222)

14.[【死磕Java并发】—-深入分析CAS](http://cmsblogs.com/?p=2235)

15.[【死磕Java并发】—–J.U.C之并发工具类：CyclicBarrier](http://cmsblogs.com/?p=2241)

16.[【死磕Java并发】—–J.U.C之并发工具类：CountDownLatch](http://cmsblogs.com/?p=2253)

17.[【死磕Java并发】—–J.U.C之并发工具类：Semaphore](http://cmsblogs.com/?p=2263)

18.[【死磕Java并发】—–J.U.C之并发工具类：Exchanger](http://cmsblogs.com/?p=2269)

19.[【死磕Java并发】—–J.U.C之Java并发容器：ConcurrentHashMap](http://cmsblogs.com/?p=2283)

20.[【死磕Java并发】—–J.U.C之ConcurrentHashMap红黑树转换分析](http://cmsblogs.com/?p=2329)

21.[【死磕Java并发】—–J.U.C之Java并发容器：ConcurrentLinkedQueue](http://cmsblogs.com/?p=2353)

22.[【死磕Java并发】—–J.U.C之Java并发容器：ConcurrentSkipListMap](http://cmsblogs.com/?p=2371)

23.[【死磕Java并发】—–J.U.C之阻塞队列：ArrayBlockingQueue](http://cmsblogs.com/?p=2381)

24.[【死磕Java并发】—–J.U.C之阻塞队列：PriorityBlockingQueue](http://cmsblogs.com/?p=2407)

25.[【死磕Java并发】—–J.U.C之阻塞队列：DelayQueue](http://cmsblogs.com/?p=2413)

26.[【死磕Java并发】—–J.U.C之阻塞队列：SynchronousQueue](http://cmsblogs.com/?p=2418)

27.[【死磕Java并发】—–J.U.C之阻塞队列：LinkedTransferQueue](http://cmsblogs.com/?p=2433)

28.[【死磕Java并发】—–J.U.C之阻塞队列：LinkedBlockingDeque](http://cmsblogs.com/?p=2437)

29.[【死磕Java并发】—–深入分析ThreadLocal](http://cmsblogs.com/?p=2442)

30.[【死磕Java并发】—–J.U.C之线程池：ThreadPoolExecutor](http://cmsblogs.com/?p=2448)

31.[【死磕Java并发】—–J.U.C之线程池：ScheduledThreadPoolExecutor](http://cmsblogs.com/?p=2451)